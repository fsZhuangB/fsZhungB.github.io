<!DOCTYPE html>
<html lang="zh">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>makefile学习（一） | fsZhuangB</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、Make的概念make可以利用某种规则去产生文件。假设文件a.txt依赖于b.txt和c.txt，是后面两个文件连接（cat命令）的产物，那么make需要知道下面的规则： 12a.txt:b.txt c.txt		cat b.txt c.txt &amp;gt; a.txt 也就是说，make a.txt这条命令的背后，实际上分为两步：  确认b.txt和c.txt必须已经存在。 使用cat命令将这两">
<meta name="keywords" content="开发者手册">
<meta property="og:type" content="article">
<meta property="og:title" content="makefile学习（一）">
<meta property="og:url" content="https://fszhuangb.xyz/2020/05/27/makefile学习（一）/index.html">
<meta property="og:site_name" content="fsZhuangB">
<meta property="og:description" content="一、Make的概念make可以利用某种规则去产生文件。假设文件a.txt依赖于b.txt和c.txt，是后面两个文件连接（cat命令）的产物，那么make需要知道下面的规则： 12a.txt:b.txt c.txt		cat b.txt c.txt &amp;gt; a.txt 也就是说，make a.txt这条命令的背后，实际上分为两步：  确认b.txt和c.txt必须已经存在。 使用cat命令将这两">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-05-29T08:42:38.311Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="makefile学习（一）">
<meta name="twitter:description" content="一、Make的概念make可以利用某种规则去产生文件。假设文件a.txt依赖于b.txt和c.txt，是后面两个文件连接（cat命令）的产物，那么make需要知道下面的规则： 12a.txt:b.txt c.txt		cat b.txt c.txt &amp;gt; a.txt 也就是说，make a.txt这条命令的背后，实际上分为两步：  确认b.txt和c.txt必须已经存在。 使用cat命令将这两">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  <link rel="stylesheet" href="/css/donate.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

  
    
      <body>
    
  
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container" class="container">
        <article id="post-makefile学习（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
    <div class="mobile-nav">
      <h1 class="nickname">fsZhuangB</h1>
      <a id="menu">
        &#9776; Menu
      </a>
    </div>
    
        <nav id="main-nav" class="main-nav nav-left">
    
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      makefile学习（一）
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h2 id="一、Make的概念"><a href="#一、Make的概念" class="headerlink" title="一、Make的概念"></a>一、Make的概念</h2><p>make可以利用某种规则去产生文件。假设文件a.txt依赖于b.txt和c.txt，是后面两个文件连接（cat命令）的产物，那么make需要知道下面的规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.txt:b.txt c.txt</span></span><br><span class="line">		cat b.txt c.txt &gt; a.txt</span><br></pre></td></tr></table></figure>
<p>也就是说，make a.txt这条命令的背后，实际上分为两步：</p>
<ul>
<li>确认b.txt和c.txt必须已经存在。</li>
<li>使用cat命令将这两个文件合并，输出为新文件。</li>
</ul>
<p>像这样的规则，都写在一个叫做<code>Makefile</code>的文件中，Make命令依赖这个文件进行构建。<code>Makefile</code>文件也可以写为<code>makefile</code>， 或者用命令行参数指定为其他文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make -f rules.txt</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ make --file=rules.txt</span><br></pre></td></tr></table></figure>
<p>上面的代码指定make命令依据rules.txt文件中的规则，进行构建。</p>
<p>总之，make只是一个根据指定的Shell命令进行构建的工具。它的规则很简单：</p>
<ul>
<li>规定要构建哪个文件</li>
<li>它依赖哪些源文件</li>
<li>当哪些文件有变动时，如何重新构建它。</li>
</ul>
<h2 id="二、Makefile文件格式"><a href="#二、Makefile文件格式" class="headerlink" title="二、Makefile文件格式"></a>二、Makefile文件格式</h2><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">[tab]   &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p>上面第一行冒号前面的部分，叫做“目标”（target），冒号后面的部分叫做“前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着“命令”（commands）。</p>
<ul>
<li>目标是必须的，不可省略；</li>
<li>“前置条件”和“命令”都是可选的，但是两者之间必须至少存在一个。</li>
<li>每条规则就明确两件事，构建目标的前置条件是什么，以及如何构建。</li>
</ul>
<h3 id="目标（target）"><a href="#目标（target）" class="headerlink" title="目标（target）"></a>目标（target）</h3><p>target可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。（又被称为”伪目标“）。</p>
<p>一个目标（target）构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的a.txt。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔开。</p>
<p>除了文件名，目标还可以是某个操作的名字，这被称为“伪目标”（phony target）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm *.o</span><br></pre></td></tr></table></figure>
<p>上面的代码的目标是clean，它不是文件名，而是一个操作的名字，属于“伪目标”，作用是删除对象文件。</p>
<p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>
<p>为了避免这种情况，可以明确声明clean是“伪目标”：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm *.o temp</span><br></pre></td></tr></table></figure>
<p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看手册。</p>
<p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看<a href="http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets" target="_blank" rel="noopener">手册</a>。</p>
<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>
<h3 id="前置条件（prerequisites"><a href="#前置条件（prerequisites" class="headerlink" title="前置条件（prerequisites)"></a>前置条件（prerequisites)</h3><p>生成该target所依赖的文件和/或target。</p>
<p>前置条件通常是一组文件名，之间用空格分隔。它指定了“目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），“目标”就要重新构建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result.txt: source.txt</span><br><span class="line">		cp source.txt result.txt</span><br></pre></td></tr></table></figure>
<p>上面代码中，构建result.txt的前置条件是source.txt。如果当前目录中，source.txt已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成<code>source.txt</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source.txt:</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"this is the source"</span> &gt; source.txt</span><br></pre></td></tr></table></figure>
<p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，那么每次调用<code>make source.txt</code>，它都会生成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make result.txt</span><br><span class="line">$ make result.txt</span><br></pre></td></tr></table></figure>
<p>上面命令连续执行两次<code>make result.txt</code>。第一次执行会先新建<code>source.txt</code>，然后再新建<code>result.txt</code>，第二次执行，Make发现<code>source.txt</code>没有变动（时间戳万余<code>result.txt</code>），就不会执行任何操作，<code>result.tx</code>t也不会重新生成。</p>
<p>如果需要生成多个文件，往往采用下面的写法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>: file1 file2 file3</span><br></pre></td></tr></table></figure>
<p>上面代码中，source是一个伪目标，只有三个前置文件，没有任何对应的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<p>执行<code>make source</code>命令后，就会一次性生成file1，file2，file3三个文件，这样比下面的写法更为方便：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure>
<h3 id="命令（commands）"><a href="#命令（commands）" class="headerlink" title="命令（commands）"></a>命令（commands）</h3><p>该target要执行的命令（任意的shell命令），这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说: <strong>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</strong></p>
<p>命令（commands）表示如何更新目标文件，由一行或者多行的Shell命令组成。它是构建“目标”的具体指令，它的运行结果通常就是生成目标文件。</p>
<p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量<code>.RECIPEPREFIX</code>声明。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt; echo Hello, world</span><br></pre></td></tr></table></figure>
<p>上面代码用<code>.RECIPEPREFIX</code>指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p>
<p>需要注意的是，每行命令在<strong>一个单独的shell</strong>中执行。这些Shell之间没有继承关系。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-lost:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar</span><br><span class="line">    echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure>
<p>上面代码执行后（<code>make var-lost</code>），取不到<code>foo</code>的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">		<span class="keyword">export</span> foo=bar; echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure>
<p>另一个解决办法是在换行符前加反斜杠转义。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; \</span><br><span class="line">    echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure>
<p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.ONESHELL:</span></span><br><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; </span><br><span class="line">    echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure>
<h2 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h2><p>在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<ol>
<li>如果这个工程没有编译过，那么我们所有的c文件都要被编译并且链接。</li>
<li>如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。</li>
<li>如果工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。</li>
</ol>
<p>只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。</p>
<p>那么，我们的makefile应该是下面的样子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># edit指最终生成的可执行文件</span></span><br><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>先简要说一下其中的含义：</p>
<ul>
<li>反斜杠（\）是换行符的意思，这样比较便于makefile的阅读。</li>
<li>如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 make clean 就可以了。</li>
<li>目标文件（target）包含：执行文件<code>edit</code>和中间目标文件<code>*.o</code></li>
<li>依赖文件（prerequisites）：冒号后面的<code>.c</code>文件和<code>.h</code>文件。每一个<code>.o</code>文件都有一组依赖文件，而这些<code>.o</code>文件又是执行文件<code>edit</code>的依赖文件。——依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</li>
<li>操作系统命令（command）：在确定好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令。（默认情况下一定要以一个<code>Tab</code>键作为开头！）</li>
</ul>
<p>记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者targets不存在的话，那么make会执行后续定义的命令。</p>
<p><strong>另外要注意的一点是：</strong></p>
<ul>
<li><code>clean</code>不是一个文件，它只不过是一个动作名字，有点像c语言中的label一样，其冒号后什么也没有。这也就是前文中说的”伪目标“的概念。</li>
<li>那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。<strong>要执行其后的命令，就要在make命令后明显得指出这个label的名字。</strong>这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</li>
</ul>
<h3 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h3><ol>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果edit文件不存在，或是edit所依赖的后面的 <code>.o</code> 文件的文件修改时间要比 <code>edit</code> 这个文件新，那么，他就会执行后面所定义的命令来生成 <code>edit</code> 这个文件。</li>
<li>如果 <code>edit</code> 所依赖的 <code>.o</code> 文件也不存在，那么make会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如果找到则再根据那一个规则生成 <code>.o</code> 文件。（这有点像一个堆栈的过程）</li>
<li>当然，你的C文件和H文件是存在的啦，于是make会生成 <code>.o</code> 文件，然后再用 <code>.o</code> 文件生成make的终极任务，也就是执行文件 <code>edit</code> 了。</li>
</ol>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 <code>file.c</code> ，那么根据我们的依赖性，我们的目标 <code>file.o</code> 会被重编译（也就是在这个依性关系后面所定义的命令），于是 <code>file.o</code> 的文件也是最新的啦，于是 <code>file.o</code> 的文件修改时间要比 <code>edit</code> 要新，所以 <code>edit</code> 也会被重新链接了（详见 <code>edit</code> 目标文件后定义的命令）。</p>
<p>而如果我们改变了 <code>command.h</code> ，那么， <code>kdb.o</code> 、 <code>command.o</code> 和 <code>files.o</code> 都会被重编译，并且， <code>edit</code> 会被重链接。</p>
<h2 id="makefile中使用变量"><a href="#makefile中使用变量" class="headerlink" title="makefile中使用变量"></a>makefile中使用变量</h2><p>在上面的例子中，先让我们看看edit的规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>.o</code> 文件的字符串被重复了两次，如果我们的工程需要加入一个新的 <code>.o</code> 文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在<code>clean</code>中）。当然，我们的<code>makefile</code>并不复杂，所以在两个地方加也不累，但如果<code>makefile</code>变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了<code>makefile</code>的易维护，在makefile中我们可以使用变量。<code>makefile</code>的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p>
<p>比如，我们声明一个变量，叫 <code>objects</code> ， <code>OBJECTS</code> ， <code>objs</code> ， <code>OBJS</code> ， <code>obj</code> 或是 <code>OBJ</code> ，反正不管什么啦，只要能够表示<code>obj</code>文件就行了。我们在makefile一开始就这样定义：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">     insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>于是，我们就可以很方便地在我们的makefile中以<code>$(objects)</code>的方式来使用这个变量了，于是我们的改良版makefile就变成下面的样子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>于是如果有新的 <code>.o</code> 文件加入，我们只需简单地修改一下 <code>objects</code> 变量就可以了。</p>
<h2 id="makefile自动推导"><a href="#makefile自动推导" class="headerlink" title="makefile自动推导"></a>makefile自动推导</h2><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 <code>.o</code> 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的新makefile又出炉了。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">	insert.o search.o files.o utils.o</span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">	cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o  : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o  : defs.h buffer.h</span><br><span class="line">search.o  : defs.h buffer.h</span><br><span class="line">files.o   : defs.h buffer.h command.h</span><br><span class="line">utils.o   : defs.h</span><br><span class="line">.PHONY    : clean</span><br><span class="line">clean :</span><br><span class="line">	rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<h2 id="收拢重复文件"><a href="#收拢重复文件" class="headerlink" title="收拢重复文件"></a>收拢重复文件</h2><p>如果觉得<code>.o</code>和<code>.h</code>文件实在是太多太重复，可以将它们收拢起来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">	cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的 .o 文件，那就理不清楚了。</p>
<h1 id="makefile学习"><a href="#makefile学习" class="headerlink" title="makefile学习"></a>makefile学习</h1><h2 id="一、Make的概念-1"><a href="#一、Make的概念-1" class="headerlink" title="一、Make的概念"></a>一、Make的概念</h2><p>make可以利用某种规则去产生文件。假设文件a.txt依赖于b.txt和c.txt，是后面两个文件连接（cat命令）的产物，那么make需要知道下面的规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.txt:b.txt c.txt</span></span><br><span class="line">		cat b.txt c.txt &gt; a.txt</span><br></pre></td></tr></table></figure>
<p>也就是说，make a.txt这条命令的背后，实际上分为两步：</p>
<ul>
<li>确认b.txt和c.txt必须已经存在。</li>
<li>使用cat命令将这两个文件合并，输出为新文件。</li>
</ul>
<p>像这样的规则，都写在一个叫做<code>Makefile</code>的文件中，Make命令依赖这个文件进行构建。<code>Makefile</code>文件也可以写为<code>makefile</code>， 或者用命令行参数指定为其他文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make -f rules.txt</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ make --file=rules.txt</span><br></pre></td></tr></table></figure>
<p>上面的代码指定make命令依据rules.txt文件中的规则，进行构建。</p>
<p>总之，make只是一个根据指定的Shell命令进行构建的工具。它的规则很简单：</p>
<ul>
<li>规定要构建哪个文件</li>
<li>它依赖哪些源文件</li>
<li>当哪些文件有变动时，如何重新构建它。</li>
</ul>
<h2 id="二、Makefile文件格式-1"><a href="#二、Makefile文件格式-1" class="headerlink" title="二、Makefile文件格式"></a>二、Makefile文件格式</h2><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">[tab]   &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p>上面第一行冒号前面的部分，叫做“目标”（target），冒号后面的部分叫做“前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着“命令”（commands）。</p>
<ul>
<li>目标是必须的，不可省略；</li>
<li>“前置条件”和“命令”都是可选的，但是两者之间必须至少存在一个。</li>
<li>每条规则就明确两件事，构建目标的前置条件是什么，以及如何构建。</li>
</ul>
<h3 id="目标（target）-1"><a href="#目标（target）-1" class="headerlink" title="目标（target）"></a>目标（target）</h3><p>target可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。（又被称为”伪目标“）。</p>
<p>一个目标（target）构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的a.txt。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔开。</p>
<p>除了文件名，目标还可以是某个操作的名字，这被称为“伪目标”（phony target）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm *.o</span><br></pre></td></tr></table></figure>
<p>上面的代码的目标是clean，它不是文件名，而是一个操作的名字，属于“伪目标”，作用是删除对象文件。</p>
<p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>
<p>为了避免这种情况，可以明确声明clean是“伪目标”：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm *.o temp</span><br></pre></td></tr></table></figure>
<p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看手册。</p>
<p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看<a href="http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets" target="_blank" rel="noopener">手册</a>。</p>
<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>
<h3 id="前置条件（prerequisites-1"><a href="#前置条件（prerequisites-1" class="headerlink" title="前置条件（prerequisites)"></a>前置条件（prerequisites)</h3><p>生成该target所依赖的文件和/或target。</p>
<p>前置条件通常是一组文件名，之间用空格分隔。它指定了“目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），“目标”就要重新构建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result.txt: source.txt</span><br><span class="line">		cp source.txt result.txt</span><br></pre></td></tr></table></figure>
<p>上面代码中，构建result.txt的前置条件是source.txt。如果当前目录中，source.txt已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成<code>source.txt</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source.txt:</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"this is the source"</span> &gt; source.txt</span><br></pre></td></tr></table></figure>
<p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，那么每次调用<code>make source.txt</code>，它都会生成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make result.txt</span><br><span class="line">$ make result.txt</span><br></pre></td></tr></table></figure>
<p>上面命令连续执行两次<code>make result.txt</code>。第一次执行会先新建<code>source.txt</code>，然后再新建<code>result.txt</code>，第二次执行，Make发现<code>source.txt</code>没有变动（时间戳万余<code>result.txt</code>），就不会执行任何操作，<code>result.tx</code>t也不会重新生成。</p>
<p>如果需要生成多个文件，往往采用下面的写法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>: file1 file2 file3</span><br></pre></td></tr></table></figure>
<p>上面代码中，source是一个伪目标，只有三个前置文件，没有任何对应的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<p>执行<code>make source</code>命令后，就会一次性生成file1，file2，file3三个文件，这样比下面的写法更为方便：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure>
<h3 id="命令（commands）-1"><a href="#命令（commands）-1" class="headerlink" title="命令（commands）"></a>命令（commands）</h3><p>该target要执行的命令（任意的shell命令），这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说: <strong>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</strong></p>
<p>命令（commands）表示如何更新目标文件，由一行或者多行的Shell命令组成。它是构建“目标”的具体指令，它的运行结果通常就是生成目标文件。</p>
<p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量<code>.RECIPEPREFIX</code>声明。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt; echo Hello, world</span><br></pre></td></tr></table></figure>
<p>上面代码用<code>.RECIPEPREFIX</code>指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p>
<p>需要注意的是，每行命令在<strong>一个单独的shell</strong>中执行。这些Shell之间没有继承关系。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-lost:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar</span><br><span class="line">    echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure>
<p>上面代码执行后（<code>make var-lost</code>），取不到<code>foo</code>的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">		<span class="keyword">export</span> foo=bar; echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure>
<p>另一个解决办法是在换行符前加反斜杠转义。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; \</span><br><span class="line">    echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure>
<p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.ONESHELL:</span></span><br><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; </span><br><span class="line">    echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure>
<h2 id="三、实例-1"><a href="#三、实例-1" class="headerlink" title="三、实例"></a>三、实例</h2><p>在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<ol>
<li>如果这个工程没有编译过，那么我们所有的c文件都要被编译并且链接。</li>
<li>如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。</li>
<li>如果工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。</li>
</ol>
<p>只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。</p>
<p>那么，我们的makefile应该是下面的样子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># edit指最终生成的可执行文件</span></span><br><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>先简要说一下其中的含义：</p>
<ul>
<li>反斜杠（\）是换行符的意思，这样比较便于makefile的阅读。</li>
<li>如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 make clean 就可以了。</li>
<li>目标文件（target）包含：执行文件<code>edit</code>和中间目标文件<code>*.o</code></li>
<li>依赖文件（prerequisites）：冒号后面的<code>.c</code>文件和<code>.h</code>文件。每一个<code>.o</code>文件都有一组依赖文件，而这些<code>.o</code>文件又是执行文件<code>edit</code>的依赖文件。——依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</li>
<li>操作系统命令（command）：在确定好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令。（默认情况下一定要以一个<code>Tab</code>键作为开头！）</li>
</ul>
<p>记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者targets不存在的话，那么make会执行后续定义的命令。</p>
<p><strong>另外要注意的一点是：</strong></p>
<ul>
<li><code>clean</code>不是一个文件，它只不过是一个动作名字，有点像c语言中的label一样，其冒号后什么也没有。这也就是前文中说的”伪目标“的概念。</li>
<li>那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。<strong>要执行其后的命令，就要在make命令后明显得指出这个label的名字。</strong>这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</li>
</ul>
<h3 id="make是如何工作的-1"><a href="#make是如何工作的-1" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h3><ol>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果edit文件不存在，或是edit所依赖的后面的 <code>.o</code> 文件的文件修改时间要比 <code>edit</code> 这个文件新，那么，他就会执行后面所定义的命令来生成 <code>edit</code> 这个文件。</li>
<li>如果 <code>edit</code> 所依赖的 <code>.o</code> 文件也不存在，那么make会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如果找到则再根据那一个规则生成 <code>.o</code> 文件。（这有点像一个堆栈的过程）</li>
<li>当然，你的C文件和H文件是存在的啦，于是make会生成 <code>.o</code> 文件，然后再用 <code>.o</code> 文件生成make的终极任务，也就是执行文件 <code>edit</code> 了。</li>
</ol>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 <code>file.c</code> ，那么根据我们的依赖性，我们的目标 <code>file.o</code> 会被重编译（也就是在这个依性关系后面所定义的命令），于是 <code>file.o</code> 的文件也是最新的啦，于是 <code>file.o</code> 的文件修改时间要比 <code>edit</code> 要新，所以 <code>edit</code> 也会被重新链接了（详见 <code>edit</code> 目标文件后定义的命令）。</p>
<p>而如果我们改变了 <code>command.h</code> ，那么， <code>kdb.o</code> 、 <code>command.o</code> 和 <code>files.o</code> 都会被重编译，并且， <code>edit</code> 会被重链接。</p>
<h2 id="makefile中使用变量-1"><a href="#makefile中使用变量-1" class="headerlink" title="makefile中使用变量"></a>makefile中使用变量</h2><p>在上面的例子中，先让我们看看edit的规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>.o</code> 文件的字符串被重复了两次，如果我们的工程需要加入一个新的 <code>.o</code> 文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在<code>clean</code>中）。当然，我们的<code>makefile</code>并不复杂，所以在两个地方加也不累，但如果<code>makefile</code>变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了<code>makefile</code>的易维护，在makefile中我们可以使用变量。<code>makefile</code>的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p>
<p>比如，我们声明一个变量，叫 <code>objects</code> ， <code>OBJECTS</code> ， <code>objs</code> ， <code>OBJS</code> ， <code>obj</code> 或是 <code>OBJ</code> ，反正不管什么啦，只要能够表示<code>obj</code>文件就行了。我们在makefile一开始就这样定义：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">     insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>于是，我们就可以很方便地在我们的makefile中以<code>$(objects)</code>的方式来使用这个变量了，于是我们的改良版makefile就变成下面的样子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>于是如果有新的 <code>.o</code> 文件加入，我们只需简单地修改一下 <code>objects</code> 变量就可以了。</p>
<h2 id="makefile自动推导-1"><a href="#makefile自动推导-1" class="headerlink" title="makefile自动推导"></a>makefile自动推导</h2><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 <code>.o</code> 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的新makefile又出炉了。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">	insert.o search.o files.o utils.o</span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">	cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o  : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o  : defs.h buffer.h</span><br><span class="line">search.o  : defs.h buffer.h</span><br><span class="line">files.o   : defs.h buffer.h command.h</span><br><span class="line">utils.o   : defs.h</span><br><span class="line">.PHONY    : clean</span><br><span class="line">clean :</span><br><span class="line">	rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<h2 id="收拢重复文件-1"><a href="#收拢重复文件-1" class="headerlink" title="收拢重复文件"></a>收拢重复文件</h2><p>如果觉得<code>.o</code>和<code>.h</code>文件实在是太多太重复，可以将它们收拢起来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">	cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的 .o 文件，那就理不清楚了。</p>
<h2 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a>清空目标文件的规则</h2><p>每个Makefile中都应该写一个清空目标文件（ .o 和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。一般可以写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	rm edit $(objects)</span><br></pre></td></tr></table></figure></p>
<p>也可以写成伪目标的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	-rm edit $(objects)</span><br></pre></td></tr></table></figure>
<p>.<code>PHONY</code> 表示 <code>clean</code> 是一个“伪目标”。在<code>rm</code>命令前面加了一个小减号的意思是，也许某些文件出现问题，但不要管，继续做后面的事情。<code>clean</code>的规则约定俗成的是放在文件的最后。</p>

      
      <div id="donate" class="donate">
        <a id="github" href="https://github.com/fsZhuangB" target="_blank" class="pos-f tr3" title="Github"></a>
	      <div id="DonateText" class="tr3">Donate</div>
	      <ul id="donateBox" class="list pos-f tr3">
		      <li id="PayPal"><a href="" target="_blank">PayPal</a></li>
		      <li id="BTC" data-footnote="Copy addres and show QRCode"><button id="BTCBn"  data-clipboard-target="#btc-key" alt="Copy to clipboard">Bitcoin</button></li>
		      <li id="AliPay">AliPay</li>
		      <li id="WeChat">WeChat</li>
	      </ul>
	      <div id="QRBox" class="pos-f left-100">
		      <div id="BTCQR" class="MainBox" style="background-image: url()"></div>
		      <div id="AliPayQR" class="MainBox" style="background-image: url()"></div>
		      <div id="WeChatQR" class="MainBox" style="background-image: url()"></div>
	      </div>
	      <!-- Bitcoin 账号 -->
	      <input id="btc-key" type="text" value="" readonly="readonly">
      </div>
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2020/05/27/makefile学习（一）/" class="article-date">
  <time datetime="2020-05-27T09:42:28.000Z" itemprop="datePublished">2020-05-27</time>
</a>

        </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发者手册/">开发者手册</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2021/10/31/python-sorted-function/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          python sorted function
        
      </div>
    </a>
  
  
    <a href="/2020/05/27/编译器的工作过程/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">编译器的工作过程</div>
    </a>
  
</nav>


  
</article>







<!-- 
  
  <!-- LiveRe City install code -->
<!-- <div id="lv-container" data-id="city" data-uid="MTAyMC8zNzYzMi8xNDE2Mw==">
        <script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
        </script>
<noscript> Please activate JavaScript for write a comment in LiveRe</noscript>
</div> -->
<!-- completed City install code -->

  
 -->


      </div>
      
    <footer id="footer" class="post-footer footer">
      
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>But I was so much older then, I’m younger than that now.</p>


<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

      </div>
    </footer>
    

      





<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.10/clipboard.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  </body>
</html>
