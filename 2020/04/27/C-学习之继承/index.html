<!DOCTYPE html>
<html lang="zh">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>C++学习之继承 | fsZhuangB</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="继承的概念继承（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程；例如类 B 继承于类 A，那么 B 就拥有 A 的成员变量和成员函数；被继承的类称为父类或基类，继承的类称为子类或派生类； 派生类除了拥有基类的成员，还可以定义自己的新成员，以增强类的功能； 继承权限继承方式限定了基类成员在派生类中的访问权限，包括 public（公有的）、private（私有的）和 p">
<meta name="keywords" content="开发者手册">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习之继承">
<meta property="og:url" content="https://fszhuangb.xyz/2020/04/27/C-学习之继承/index.html">
<meta property="og:site_name" content="fsZhuangB">
<meta property="og:description" content="继承的概念继承（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程；例如类 B 继承于类 A，那么 B 就拥有 A 的成员变量和成员函数；被继承的类称为父类或基类，继承的类称为子类或派生类； 派生类除了拥有基类的成员，还可以定义自己的新成员，以增强类的功能； 继承权限继承方式限定了基类成员在派生类中的访问权限，包括 public（公有的）、private（私有的）和 p">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://raw.githubusercontent.com/fsZhuangB/Photos_Of_Blog/master/photos/Screen_Shot_2020-04-27_at_7.13.41_PM.png">
<meta property="og:updated_time" content="2020-04-27T12:04:55.909Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++学习之继承">
<meta name="twitter:description" content="继承的概念继承（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程；例如类 B 继承于类 A，那么 B 就拥有 A 的成员变量和成员函数；被继承的类称为父类或基类，继承的类称为子类或派生类； 派生类除了拥有基类的成员，还可以定义自己的新成员，以增强类的功能； 继承权限继承方式限定了基类成员在派生类中的访问权限，包括 public（公有的）、private（私有的）和 p">
<meta name="twitter:image" content="https://raw.githubusercontent.com/fsZhuangB/Photos_Of_Blog/master/photos/Screen_Shot_2020-04-27_at_7.13.41_PM.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  <link rel="stylesheet" href="/css/donate.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

  
    
      <body>
    
  
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container" class="container">
        <article id="post-C-学习之继承" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
    <div class="mobile-nav">
      <h1 class="nickname">fsZhuangB</h1>
      <a id="menu">
        &#9776; Menu
      </a>
    </div>
    
        <nav id="main-nav" class="main-nav nav-left">
    
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++学习之继承
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p><code>继承（Inheritance）</code>可以理解为一个类从另一个类获取成员变量和成员函数的过程；例如类 B 继承于类 A，那么 B 就拥有 A 的成员变量和成员函数；<strong>被继承的类称为父类或基类，继承的类称为子类或派生类</strong>；</p>
<p>派生类除了拥有基类的成员，还可以定义自己的新成员，以增强类的功能；</p>
<h2 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h2><p>继承方式限定了基类成员在派生类中的访问权限，包括 public（公有的）、private（私有的）和 protected（受保护的）；此项是可选项，如果不写，默认为 private（成员变量和成员函数默认也是 private）；</p>
<h2 id="改变访问权限"><a href="#改变访问权限" class="headerlink" title="改变访问权限"></a>改变访问权限</h2><p>使用 using 关键字可以改变基类成员在派生类中的访问权限，例如将 public 改为 private、将 protected 改为 public 等：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::d;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> A::b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> A::c;</span><br><span class="line">    <span class="keyword">using</span> A::e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：在派生类中只能访问基类的非 private 成员，使用 using 时，也必须遵循这个规则；</p>
<p>对于父类的 public/protected 成员：using 可以将其改为 public、protected、private 属性；</p>
<p>对于父类的 private 成员：由于在派生类中不可见，所以也就不能使用 using 改变属性；</p>
<h2 id="继承时的名字屏蔽"><a href="#继承时的名字屏蔽" class="headerlink" title="继承时的名字屏蔽"></a>继承时的名字屏蔽</h2><p>如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员；所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的；</p>
<p>比如，在父类 A 和 派生类 B 中都有函数 func()，在调用的时候就会发生名字屏蔽：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"class A: func()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"class B: func()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.func();</span><br><span class="line">    b.A::func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果为：</span></span><br><span class="line">$ ./a.out</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> func()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> func()</span><br></pre></td></tr></table></figure>
<p>在基类 A 和 派生类 B 中都存在一个名字一样的函数 func()，名字一样，造成屏蔽；</p>
<p>由于派生类中的 func() 优先级更高，如不明确指定使用父类的 func()，默认调用派生类的 func() 函数；</p>
<p>需要注意的是：</p>
<blockquote>
<p><strong>基类成员函数和派生类成员函数不构成重载。</strong></p>
</blockquote>
<p>基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽；</p>
<p>换句话说，基类成员函数和派生类成员函数<strong>不会</strong>构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class A: func()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class A: func(int)\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class B: func(char)\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class B: func(float)\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.func(<span class="string">'A'</span>);</span><br><span class="line">    b.func(<span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line"><span class="comment">//    b.func();</span></span><br><span class="line"><span class="comment">//    b.func(10);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/fsZhuangB/Photos_Of_Blog/master/photos/Screen_Shot_2020-04-27_at_7.13.41_PM.png" alt="C/Screen_Shot_2020-04-27_at_7.13.41_PM.png"></p>
<h2 id="类继承时的作用域嵌套"><a href="#类继承时的作用域嵌套" class="headerlink" title="类继承时的作用域嵌套"></a>类继承时的作用域嵌套</h2><p>类其实也是一种作用域，每个类都会定义它自己的作用域，在这个作用域内我们再定义类的成员；</p>
<p>当存在继承关系时，派生类的作用域嵌套在基类的作用域之内，如果一个名字在派生类的作用域内无法找到，编译器会继续到外层的基类作用域中查找该名字的定义；</p>
<p>换句话说，作用域能够彼此包含，被包含（或者说被嵌套）的作用域称为<strong>内层作用域</strong>（inner scope），包含着别的作用域的作用域称为<strong>外层作用域</strong>（outer scope）；</p>
<p>一旦在外层作用域中声明（或者定义）了某个名字，那么它所嵌套着的所有内层作用域中都能访问这个名字；同时，允许在内层作用域中重新定义外层作用域中已有的名字；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class A: func()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class A: print()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class B: func()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class C: print()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.func();</span><br><span class="line">    b.print(); <span class="comment">// 调用A的print()</span></span><br><span class="line">    C c;</span><br><span class="line">    c.func();  <span class="comment">// 调用B的func()</span></span><br><span class="line">    c.print(); <span class="comment">// 调用C的print()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line">Class B: func()</span><br><span class="line">Class A: print()</span><br><span class="line">Class B: func()</span><br><span class="line">Class C: print()</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果当前类中没有找到该成员，就逐个的往外层作用域中查找，直到找到为止，否则就报错；</p>
<p>这个过程叫做<strong>名字查找（name lookup）</strong>，也就是在作用域链中寻找与所用名字最匹配的声明（或定义）的过程；</p>
<p>对于成员变量这个过程很好理解，对于成员函数要引起注意，编译器<strong>仅仅是根据函数的名字来查找的，不会理会函数的参数</strong>；换句话说，一旦内层作用域有同名的函数，不管有几个，编译器都不会再到外层作用域中查找，编译器仅把内层作用域中的这些同名函数作为一组候选函数；这组候选函数就是一组重载函数；</p>
<p>说白了，只有一个作用域内的同名函数才具有重载关系，不同作用域内的同名函数会造成遮蔽，使得外层函数无效。派生类和基类拥有不同的作用域，所以它们的同名函数不具有重载关系；</p>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>前面我们说基类的成员函数可以被继承，可以通过派生类的对象访问，但这仅仅指的是普通的成员函数，<strong>类的构造函数不能被继承</strong>；</p>
<p>构造函数不能被继承是有道理的，因为即使继承了，它的名字和派生类的名字也不一样，不能成为派生类的构造函数，当然更不能成为普通的成员函数；</p>
<p>C++中，通过派生类创建对象时<strong>必须要调用基类的构造函数</strong>。这主要是因为，在设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是大部分基类都有 private 属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化；</p>
<p>所以，有以下几个注意点：</p>
<ul>
<li>定义派生类构造函数时最好指明基类构造函数；</li>
<li>如果不指明，就调用基类的默认构造函数（不带参数的构造函数）；</li>
<li>如果没有默认构造函数，那么编译失败；</li>
<li>派生类构造函数总是先调用基类构造函数再执行其他代码（包括参数初始化表以及函数体中的代码）；</li>
<li><strong>只能将基类构造函数的调用放在函数头部，不能放在函数体中</strong>；</li>
</ul>
<h3 id="构造函数调用顺序"><a href="#构造函数调用顺序" class="headerlink" title="构造函数调用顺序"></a>构造函数调用顺序</h3><p>基类构造函数总是被<strong>优先调用</strong>，这说明创建派生类对象时，会先调用基类构造函数，再调用派生类构造函数，如果继承关系有好几层的话，例如：A –&gt; B –&gt; C那么创建 C 类对象时构造函数的执行顺序为：A类构造函数 –&gt; B类构造函数 –&gt; C类构造函数</p>
<p><strong>构造函数的调用顺序是按照继承的层次自顶向下、从基类再到派生类的。</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class_A A()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class_A A(int)\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class_B B()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    B(<span class="keyword">char</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class_B B(char)\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() : B(<span class="string">'A'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class_C C()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line"><span class="function">Class_A <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Class_B <span class="title">B</span><span class="params">(<span class="keyword">char</span>)</span></span></span><br><span class="line"><span class="function">Class_C <span class="title">C</span><span class="params">()</span></span></span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h2><p><strong>和构造函数类似，析构函数也不能被继承</strong>；与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉；</p>
<p>另外<strong>析构函数的执行顺序和构造函数的执行顺序也刚好相反</strong>：</p>
<ul>
<li>创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数；</li>
<li>而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class_A A()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"~A()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class_B B()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"~B()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Class_C C()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~C() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"~C()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line"><span class="function">Class_A <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Class_B <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Class_C <span class="title">C</span><span class="params">()</span></span></span><br><span class="line">~C()</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></table></figure>

      
      <div id="donate" class="donate">
        <a id="github" href="https://github.com/fsZhuangB" target="_blank" class="pos-f tr3" title="Github"></a>
	      <div id="DonateText" class="tr3">Donate</div>
	      <ul id="donateBox" class="list pos-f tr3">
		      <li id="PayPal"><a href="" target="_blank">PayPal</a></li>
		      <li id="BTC" data-footnote="Copy addres and show QRCode"><button id="BTCBn"  data-clipboard-target="#btc-key" alt="Copy to clipboard">Bitcoin</button></li>
		      <li id="AliPay">AliPay</li>
		      <li id="WeChat">WeChat</li>
	      </ul>
	      <div id="QRBox" class="pos-f left-100">
		      <div id="BTCQR" class="MainBox" style="background-image: url()"></div>
		      <div id="AliPayQR" class="MainBox" style="background-image: url()"></div>
		      <div id="WeChatQR" class="MainBox" style="background-image: url()"></div>
	      </div>
	      <!-- Bitcoin 账号 -->
	      <input id="btc-key" type="text" value="" readonly="readonly">
      </div>
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2020/04/27/C-学习之继承/" class="article-date">
  <time datetime="2020-04-27T12:02:16.000Z" itemprop="datePublished">2020-04-27</time>
</a>

        </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发者手册/">开发者手册</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <span id="article-nav-newer" class="article-nav-link-wrap newer"></span>
  
  
    <a href="/2020/04/22/C-学习之智能指针/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C++学习之智能指针</div>
    </a>
  
</nav>


  
</article>







<!-- 
  
  <!-- LiveRe City install code -->
<!-- <div id="lv-container" data-id="city" data-uid="MTAyMC8zNzYzMi8xNDE2Mw==">
        <script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
        </script>
<noscript> Please activate JavaScript for write a comment in LiveRe</noscript>
</div> -->
<!-- completed City install code -->

  
 -->


      </div>
      
    <footer id="footer" class="post-footer footer">
      
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>But I was so much older then, I’m younger than that now.</p>


<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

      </div>
    </footer>
    

      





<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.10/clipboard.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </body>
</html>
